{"version":3,"file":"index.mjs","sources":["../lib/non_core_shape.js","../lib/base.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport normalizeIndices from '@stdlib/ndarray-base-to-unique-normalized-indices';\nimport indicesComplement from '@stdlib/array-base-indices-complement';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Returns the shape defined by the dimensions which are **not** included in a list of dimensions.\n*\n* @private\n* @param {NonNegativeIntegerArray} shape - input ndarray\n* @param {IntegerArray} dims - list of dimensions\n* @returns {NonNegativeIntegerArray} shape\n*/\nfunction nonCoreShape( shape, dims ) { // TODO: consider moving to a `@stdlib/ndarray/base` utility\n\tvar ind = normalizeIndices( dims, shape.length-1 );\n\tif ( ind === null ) {\n\t\t// Note: this is an error condition, as `null` is returned when provided out-of-bounds indices...\n\t\treturn [];\n\t}\n\treturn takeIndexed( shape, indicesComplement( shape.length, ind ) );\n}\n\n\n// EXPORTS //\n\nexport default nonCoreShape;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport dtypes from '@stdlib/ndarray-dtypes';\nimport gsorthp from '@stdlib/blas-ext-base-ndarray-gsorthp';\nimport dsorthp from '@stdlib/blas-ext-base-ndarray-dsorthp';\nimport ssorthp from '@stdlib/blas-ext-base-ndarray-ssorthp';\nimport factory from '@stdlib/ndarray-base-nullary-strided1d-dispatch-factory';\n\n\n// VARIABLES //\n\nvar idtypes0 = dtypes( 'real_and_generic' ); // input ndarray\nvar idtypes1 = dtypes( 'real_and_generic' ); // sortOrder ndarray\nvar odtypes = dtypes( 'real_and_generic' );\nvar table = {\n\t'types': [\n\t\t'float64', // input/output\n\t\t'float32'  // input/output\n\t],\n\t'fcns': [\n\t\tdsorthp,\n\t\tssorthp\n\t],\n\t'default': gsorthp\n};\nvar options = {\n\t'strictTraversalOrder': true\n};\n\n\n// MAIN //\n\n/**\n* Sorts an input ndarray along one or more ndarray dimensions using heapsort.\n*\n* @private\n* @name sorthp\n* @type {Function}\n* @param {ndarray} x - input ndarray\n* @param {ndarray} sortOrder - ndarray containing the sort order\n* @param {Options} [options] - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform operation\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} second argument must be an ndarray-like object\n* @throws {TypeError} options argument must be an object\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-to-array';\n* import scalar2ndarray from '@stdlib/ndarray-from-scalar';\n* import ndarray from '@stdlib/ndarray-ctor';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, -3.0, 4.0, -5.0, 6.0 ] );\n*\n* // Define the shape of the input array:\n* var sh = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create an input ndarray:\n* var x = new ndarray( 'float64', xbuf, sh, sx, ox, 'row-major' );\n*\n* // Create an ndarray containing the sort order:\n* var sortOrder = scalar2ndarray( 1.0, {\n*     'dtype': 'float64'\n* });\n*\n* // Perform operation:\n* var out = sorthp( x, sortOrder );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( out );\n* // returns [ [ [ -5.0, -3.0 ] ], [ [ 1.0, 2.0 ] ], [ [ 4.0, 6.0 ] ] ]\n*/\nvar sorthp = factory( table, [ idtypes0, idtypes1 ], odtypes, options );\n\n\n// EXPORTS //\n\nexport default sorthp;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-len */\n\n'use strict';\n\n// MODULES //\n\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { isPrimitive as isNumber } from '@stdlib/assert-is-number';\nimport { isPrimitive as isString } from '@stdlib/assert-is-string';\nimport isndarrayLike from '@stdlib/assert-is-ndarray-like';\nimport isRealFloatingDataType from '@stdlib/ndarray-base-assert-is-real-floating-point-data-type';\nimport isSignedIntegerDataType from '@stdlib/ndarray-base-assert-is-signed-integer-data-type';\nimport broadcastScalar from '@stdlib/ndarray-base-broadcast-scalar';\nimport maybeBroadcastArray from '@stdlib/ndarray-base-maybe-broadcast-array';\nimport getDType from '@stdlib/ndarray-dtype';\nimport getShape from '@stdlib/ndarray-shape';\nimport getOrder from '@stdlib/ndarray-order';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport nonCoreShape from './non_core_shape.js';\nimport base from './base.js';\n\n\n// FUNCTIONS //\n\n/**\n* Returns a boolean indicating if a value is a string literal specifying ascending sort order.\n*\n* @private\n* @param {*} value - input value\n* @returns {boolean} boolean result\n*/\nfunction isAscending( value ) {\n\treturn ( value === 'asc' || value === 'ascending' );\n}\n\n/**\n* Returns a boolean indicating if a value is a string literal specifying descending sort order.\n*\n* @private\n* @param {*} value - input value\n* @returns {boolean} boolean result\n*/\nfunction isDescending( value ) {\n\treturn ( value === 'desc' || value === 'descending' );\n}\n\n/**\n* Converts a string literal to a numeric sort order value.\n*\n* @private\n* @param {string} value - input value\n* @throws {TypeError} must provide a supported string\n* @returns {number} sort order\n*/\nfunction string2order( value ) {\n\tif ( isAscending( value ) ) {\n\t\treturn 1;\n\t}\n\tif ( isDescending( value ) ) {\n\t\treturn -1;\n\t}\n\tthrow new TypeError( format( 'invalid argument. Second argument must be a valid sort order. Value: `%s`.', value ) );\n}\n\n/**\n* Normalize a numeric sort order value.\n*\n* ## Notes\n*\n* -   Normalizing numeric sort order values to canonical values `-1`, `+1`, and `0` ensures that we can avoid truncation rounding errors when casting a provided sort order to the data type of the input ndarray.\n*\n* @private\n* @param {number} value - input value\n* @returns {number} normalized value\n*/\nfunction normalizeOrder( value ) {\n\tif ( value < 0 ) {\n\t\treturn -1;\n\t}\n\tif ( value > 0 ) {\n\t\treturn 1;\n\t}\n\treturn value;\n}\n\n\n// MAIN //\n\n/**\n* Sorts an input ndarray along one or more ndarray dimensions using heapsort.\n*\n* @param {ndarrayLike} x - input ndarray\n* @param {(ndarrayLike|number|string)} [sortOrder=1.0] - sort order\n* @param {Options} [options] - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform operation\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} sort order argument must be either an ndarray-like object, a numeric value, or a supported string\n* @throws {TypeError} options argument must be an object\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-to-array';\n* import ndarray from '@stdlib/ndarray-ctor';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( [ 1.0, 2.0, -3.0, 4.0, -5.0, 6.0 ] );\n*\n* // Define the shape of the input array:\n* var sh = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Create an input ndarray:\n* var x = new ndarray( 'float64', xbuf, sh, sx, ox, 'row-major' );\n*\n* // Perform operation:\n* var out = sorthp( x );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( out );\n* // returns [ [ [ -5.0, -3.0 ] ], [ [ 1.0, 2.0 ] ], [ [ 4.0, 6.0 ] ] ]\n*/\nfunction sorthp( x ) {\n\tvar nargs;\n\tvar isStr;\n\tvar opts;\n\tvar ord;\n\tvar dt;\n\tvar sh;\n\tvar o;\n\n\tnargs = arguments.length;\n\n\t// Resolve input ndarray meta data:\n\tdt = getDType( x );\n\tif ( !isRealFloatingDataType( dt ) && !isSignedIntegerDataType( dt ) ) {\n\t\t// Fallback to \"generic\" only if we cannot safely cast `-1` to the data type of the input ndarray:\n\t\tdt = 'generic';\n\t}\n\tord = getOrder( x );\n\n\t// Case: sorthp( x )\n\tif ( nargs < 2 ) {\n\t\treturn base( x, broadcastScalar( 1, dt, [], ord ) );\n\t}\n\to = arguments[ 1 ];\n\n\t// Case: sorthp( x, ??? )\n\tif ( nargs === 2 ) {\n\t\t// Case: sorthp( x, sortOrder_scalar || sortOrder_string )\n\t\tisStr = isString( o );\n\t\tif ( isStr || isNumber( o ) ) {\n\t\t\treturn base( x, broadcastScalar( ( isStr ) ? string2order( o ) : normalizeOrder( o ), dt, [], ord ) );\n\t\t}\n\t\t// Case: sorthp( x, sortOrder_ndarray )\n\t\tif ( isndarrayLike( o ) ) {\n\t\t\t// As the operation is performed across all dimensions, `o` is assumed to be a zero-dimensional ndarray...\n\t\t\treturn base( x, o );\n\t\t}\n\t\t// Case: sorthp( x, opts )\n\t\topts = o;\n\t\to = 1;\n\n\t\t// Intentionally fall through...\n\t}\n\t// Case: sorthp( x, sortOrder, opts )\n\telse { // nargs > 2\n\t\topts = arguments[ 2 ];\n\t}\n\t// Case: sorthp( x, sortOrder_scalar || sortOrder_string, opts )\n\tisStr = isString( o );\n\tif ( isStr || isNumber( o ) ) {\n\t\tif ( hasOwnProp( opts, 'dims' ) ) {\n\t\t\tsh = nonCoreShape( getShape( x ), opts.dims );\n\t\t} else {\n\t\t\tsh = [];\n\t\t}\n\t\to = broadcastScalar( ( isStr ) ? string2order( o ) : normalizeOrder( o ), dt, sh, getOrder( x ) );\n\t}\n\t// Case: sorthp( x, sortOrder_ndarray, opts )\n\telse if ( isndarrayLike( o ) ) {\n\t\t// When not provided `dims`, the operation is performed across all dimensions and `o` is assumed to be a zero-dimensional ndarray; when `dims` is provided, we need to broadcast `o` to match the shape of the non-core dimensions...\n\t\tif ( hasOwnProp( opts, 'dims' ) ) {\n\t\t\to = maybeBroadcastArray( o, nonCoreShape( getShape( x ), opts.dims ) );\n\t\t}\n\t} else {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be either an ndarray, a numeric scalar value, or a supported string. Value: `%s`.', o ) );\n\t}\n\treturn base( x, o, opts );\n}\n\n\n// EXPORTS //\n\nexport default sorthp;\n"],"names":["nonCoreShape","shape","dims","ind","normalizeIndices","length","takeIndexed","indicesComplement","sorthp","factory","types","fcns","dsorthp","ssorthp","default","gsorthp","dtypes","strictTraversalOrder","string2order","value","isAscending","isDescending","TypeError","format","normalizeOrder","x","nargs","isStr","opts","ord","dt","sh","o","arguments","getDType","isRealFloatingDataType","isSignedIntegerDataType","getOrder","base","broadcastScalar","isString","isNumber","isndarrayLike","hasOwnProp","getShape","maybeBroadcastArray"],"mappings":";;6+DAqCA,SAASA,EAAcC,EAAOC,GAC7B,IAAIC,EAAMC,EAAkBF,EAAMD,EAAMI,OAAO,GAC/C,OAAa,OAARF,EAEG,GAEDG,EAAaL,EAAOM,EAAmBN,EAAMI,OAAQF,GAC7D,CCbA,IAwEIK,EAASC,EArED,CACXC,MAAS,CACR,UACA,WAEDC,KAAQ,CACPC,EACAC,GAEDC,QAAWC,GA4DiB,CAxEdC,EAAQ,oBACRA,EAAQ,qBACTA,EAAQ,oBAYR,CACbC,sBAAwB,IC0BzB,SAASC,EAAcC,GACtB,GAxBD,SAAsBA,GACrB,MAAmB,QAAVA,GAA6B,cAAVA,CAC7B,CAsBMC,CAAaD,GACjB,OAAO,EAER,GAhBD,SAAuBA,GACtB,MAAmB,SAAVA,GAA8B,eAAVA,CAC9B,CAcME,CAAcF,GAClB,OAAQ,EAET,MAAM,IAAIG,UAAWC,EAAQ,6EAA8EJ,GAC5G,CAaA,SAASK,EAAgBL,GACxB,OAAKA,EAAQ,GACJ,EAEJA,EAAQ,EACL,EAEDA,CACR,CA+CA,SAASX,EAAQiB,GAChB,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAaJ,GAXAN,EAAQO,UAAU5B,OAGlByB,EAAKI,EAAUT,GACTU,EAAwBL,IAASM,EAAyBN,KAE/DA,EAAK,WAEND,EAAMQ,EAAUZ,GAGXC,EAAQ,EACZ,OAAOY,EAAMb,EAAGc,EAAiB,EAAGT,EAAI,GAAID,IAK7C,GAHAG,EAAIC,UAAW,GAGA,IAAVP,EAAc,CAGlB,IADAC,EAAQa,EAAUR,KACJS,EAAUT,GACvB,OAAOM,EAAMb,EAAGc,EAAiB,EAAYrB,EAAcc,GAAMR,EAAgBQ,GAAKF,EAAI,GAAID,IAG/F,GAAKa,EAAeV,GAEnB,OAAOM,EAAMb,EAAGO,GAGjBJ,EAAOI,EACPA,EAAI,CAGJ,MAGAJ,EAAOK,UAAW,GAInB,IADAN,EAAQa,EAAUR,KACJS,EAAUT,GAEtBD,EADIY,EAAYf,EAAM,QACjB5B,EAAc4C,EAAUnB,GAAKG,EAAK1B,MAElC,GAEN8B,EAAIO,EAAiB,EAAYrB,EAAcc,GAAMR,EAAgBQ,GAAKF,EAAIC,EAAIM,EAAUZ,QAGxF,KAAKiB,EAAeV,GAMxB,MAAM,IAAIV,UAAWC,EAAQ,2HAA4HS,IAJpJW,EAAYf,EAAM,UACtBI,EAAIa,EAAqBb,EAAGhC,EAAc4C,EAAUnB,GAAKG,EAAK1B,OAI/D,CACD,OAAOoC,EAAMb,EAAGO,EAAGJ,EACpB"}